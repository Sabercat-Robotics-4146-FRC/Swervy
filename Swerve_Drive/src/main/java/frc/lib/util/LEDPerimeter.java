/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package frc.lib.util;

public class LEDPerimeter {
  double frameWidth = -1;
  double frameLength = -1;
  int LEDPerMeter;

  // public LEDPerimeter(double frameWidth, double frameLength, int LEDPerMeter) {
  //   this.frameWidth = frameWidth;
  //   this.frameLength = frameLength;
  //   this.LEDPerMeter = LEDPerMeter;
  // }

  public void setFrameLength(double frameLength) {
    this.frameLength = frameLength;
  }

  public void setFrameWidth(double frameWidth) {
    this.frameWidth = frameWidth;
  }

  public void setLEDPerMeter(int lEDPerMeter) {
    LEDPerMeter = lEDPerMeter;
  }

  double frameAngle = Math.atan2(frameWidth, frameLength);
  double LEDNum = frameLength;
  double distanceTraveled;
  double distanceCompleated;

  int region;
  double yFactor = 1;
  double xFactor = 1;

  public static class edgePoint {
    static double x = 0;
    static double y = 0;
  }

  public static class nearestCorner {
    static double x;
    static double y;
  }

  public double getLEDAmount() {
    return LEDNum;
  }

  public void getregion(double angle) {
    if ((angle > -frameAngle) && (angle <= frameAngle)) {
      region = 1;
    } else if ((angle > frameAngle) && (angle <= (Math.PI - frameAngle))) {
      region = 2;
    } else if ((angle > (Math.PI - frameAngle)) || (angle <= -(Math.PI - frameAngle))) {
      region = 3;
    } else {
      region = 4;
    }
  }

  public boolean testy() {
    return true;
  }

  public void setEdgePoint(double headingAngle) {
    double tanTheta = Math.tan(headingAngle);
    getregion(headingAngle);

    switch (region) {
      case 1:
        yFactor = -1;
        break;
      case 2:
        yFactor = -1;
        break;
      case 3:
        xFactor = -1;
        break;
      case 4:
        xFactor = -1;
        break;
    }

    if ((region == 1) || (region == 3)) {
      edgePoint.x += xFactor * (frameLength / 2); // "Z0"
      edgePoint.y += yFactor * (frameLength / 2) * tanTheta;
    } else {
      edgePoint.x += xFactor * (frameWidth / (2 * tanTheta)); // "Z1"
      edgePoint.y += yFactor * (frameWidth / 2);
    }
  }

  public int getLEDNum(double headingAngle) {
    headingAngle = Math.toRadians(headingAngle);
    setEdgePoint(headingAngle);
    getregion(headingAngle);
    switch (region) {
      case 1:
        distanceCompleated = 0;
        nearestCorner.x = frameLength / 2;
        if (headingAngle > (7 * Math.PI) / 4) {
          nearestCorner.y = -frameWidth / 2;
        } else {
          nearestCorner.y = frameWidth / 2;
        }
        break;
      case 2:
        distanceCompleated = frameWidth / 2;
        nearestCorner.x = frameLength / 2;
        nearestCorner.y = frameWidth / 2;
        break;
      case 3:
        distanceCompleated = frameLength + frameWidth / 2;
        nearestCorner.x = -frameLength / 2;
        nearestCorner.y = frameWidth / 2;
        break;
      case 4:
        distanceCompleated = frameLength + (3 * frameWidth) / 2;
        nearestCorner.x = -frameLength / 2;
        nearestCorner.y = -frameWidth / 2;
        break;
    }
    distanceTraveled =
        distanceCompleated
            + Math.sqrt(
                Math.pow(nearestCorner.x - edgePoint.x, 2)
                    + Math.pow(nearestCorner.y - edgePoint.y, 2));

    return (int)
        Math.round((((double) LEDNum) / (2 * (frameLength + frameWidth))) * distanceTraveled);
  }
}
