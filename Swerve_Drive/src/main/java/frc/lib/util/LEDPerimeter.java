/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package frc.lib.util;

public class LEDPerimeter {
  double frameWidth;
  double frameLength;
  int LEDPerMeter;
  int LEDNum;
  double frameAngle;

  public static class edgePoint {
    static double x = 0;
    static double y = 0;
  }

  public static class nearestCorner {
    static double x;
    static double y;
  }

  public LEDPerimeter(double frameWidth, double frameLength, int LEDPerMeter) {
    this.frameWidth = frameWidth;
    this.frameLength = frameLength;
    this.LEDPerMeter = LEDPerMeter;
    this.LEDNum = (int) Math.round((2 * (frameLength + frameWidth) / 39.87) * 30);
    this.frameAngle = Math.atan2(frameWidth / 2, frameLength / 2);
  }

  double distanceTraveled;
  double distanceCompleated;

  int region;
  double yFactor = 1;
  double xFactor = 1;

  public int getLEDAmount() {
    return LEDNum;
  }

  public double remapAngle(double headingAngle) {
    return (Math.atan2(
        ((frameWidth / 2) / Math.sin(Math.PI / 4)) * Math.sin(headingAngle),
        ((frameLength / 2) / Math.cos(Math.PI / 4)) * Math.cos(headingAngle)));
  }

  public void getregion(double angle) {
    if ((angle > -Math.PI / 4) && (angle <= Math.PI / 4)) {
      region = 1;
    } else if ((angle > Math.PI / 4) && (angle <= (3 * Math.PI) / 4)) {
      region = 2;
    } else if ((angle > (3 * Math.PI) / 4) || (angle <= -(3 * Math.PI) / 4)) {
      region = 3;
    } else {
      region = 4;
    }
  }

  public void setEdgePoint(double headingAngle) {
    double tanTheta = Math.tan(remapAngle(headingAngle));
    getregion(headingAngle);

    switch (region) {
      case 1:
        yFactor = 1;
        xFactor = 1;
        break;
      case 2:
        yFactor = 1;
        xFactor = 1;
        break;
      case 3:
        xFactor = -1;
        yFactor = -1;
        break;
      case 4:
        xFactor = -1;
        yFactor = -1;
        break;
    }

    if ((region == 1) || (region == 3)) {
      edgePoint.x += xFactor * (frameLength / 2); // "Z0"
      edgePoint.y += yFactor * (frameLength / 2) * tanTheta;
    } else {
      edgePoint.x += xFactor * (frameWidth / (2 * tanTheta)); // "Z1"
      edgePoint.y += yFactor * (frameWidth / 2);
    }
  }

  public void setNearestCorner(double headingAngle) {
    getregion(headingAngle);
    switch (region) {
      case 1:
        nearestCorner.x = frameLength / 2;
        if ((headingAngle > (-Math.PI) / 4) && (headingAngle < 0)) {
          nearestCorner.y = -frameWidth / 2;
          distanceCompleated = (2 * frameLength) + ((3 * frameWidth) / 2);
        } else {
          nearestCorner.y = 0;
          distanceCompleated = 0;
        }
        break;
      case 2:
        distanceCompleated = frameWidth / 2;
        nearestCorner.x = frameLength / 2;
        nearestCorner.y = frameWidth / 2;
        break;
      case 3:
        distanceCompleated = frameLength + frameWidth / 2;
        nearestCorner.x = -frameLength / 2;
        nearestCorner.y = frameWidth / 2;
        break;
      case 4:
        distanceCompleated = frameLength + (3 * frameWidth) / 2;
        nearestCorner.x = -frameLength / 2;
        nearestCorner.y = -frameWidth / 2;
        break;
    }
  }

  public double fetchDistanceTravled() {
    return distanceTraveled;
  }
  ;

  public double getNearestPointX() {
    return nearestCorner.x;
  }

  public double getNearestPointY() {
    return nearestCorner.y;
  }

  public double getEdgePointX() {
    return edgePoint.x;
  }

  public double getEdgePointY() {
    return edgePoint.y;
  }

  public boolean testy() {
    return true;
  }

  public int fetchRegion() {
    return region;
  }

  public int getLEDNum(double headingAngle) {
    headingAngle = Math.toRadians(headingAngle);
    setEdgePoint(headingAngle);
    setNearestCorner(headingAngle);

    distanceTraveled =
        distanceCompleated
            + Math.sqrt(
                Math.pow(nearestCorner.x - edgePoint.x, 2)
                    + Math.pow(nearestCorner.y - edgePoint.y, 2));

    return (int) Math.round(((LEDNum / (2 * (frameLength + frameWidth))) * distanceTraveled));
  }
}
